'use strict'

const canvas = document.querySelector('canvas');
const context = canvas.getContext('2d');
const menu = document.querySelector('#menu');
const bDefaultSettings = document.querySelector('#bDefaultSettings');
const [iRenderTime, iElementsSize] = [document.querySelector('#iRenderTime'), document.querySelector('#iElementsSize')];
const [iPredatorColor, iFoodColor] = [document.querySelector('#iPredatorColor'), document.querySelector('#iFoodColor')];
const [iCanvasWidth, iCanvasHeight] = [document.querySelector('#iCanvasWidth'), document.querySelector('#iCanvasHeight')];
const score = document.querySelector('#score');
const startButton = document.querySelector('#bStart');

const game = {
    predator: {positions: [[0, 0]], color: null},
    food: {positions: [/*Randomly generated by function*/], color: null},
    settings: {time: null, interval: null, advanced_settings: false, chunks: {size : null}},
    arrows: {w: false, a: false, s: false, d: false},

    start: function(){

        this.generate_food(this.food);

        this.settings.interval = setInterval(() => {

            //Limpa o canvas
            this.clear();

            //Desenha Entidades
            this.draw(this.predator, this.predator.color)
            this.draw(this.food, this.food.color);

            //Faz com que os pontos obtidos sigam a entidade
            this.follow_trail(this.predator);

            //Checa se a entidade pegou o ponto, ganha ponto a entidade, remove o alimento da arena, e gera outro alimento.
            if(this.check_eat(this.predator, this.food)) this.add_point(this.predator) && this.remove_point(this.food) && this.generate_food(this.food) && this.update_score();

            //Movimenta a entidade
            this.sides(this.predator);

            //Checa se colidiu com si mesmo e executa as instruções a seguir
            if(this.hit_himself(this.predator)) this.remove_point(this.predator) && this.update_score();

            //Checa se a entidade saiu do mapa e executa as instruções dentro da função
            this.out_of_map(this.predator);

            //Tempo de intervalo para este ciclo de instruções.
        },this.settings.time);
    },

    clear: function(){    context.clearRect(0, 0, canvas.width, canvas.height);    }, //Limpa o canvas

    draw: function(entity, color){ //Desenha [entity] e a pinta [color]
        context.fillStyle = color;
        for(let chunk of entity.positions) context.fillRect(chunk[0], chunk[1], this.settings.chunks.size, this.settings.chunks.size);
    },

    follow_trail: function(entity){    for(let last = entity.positions.length - 1; last > 0; entity.positions[last] = [...entity.positions[--last]]);    }, // Faz com que os pontos de [entity] sigam [entity]

    sides: function(entity){ // Movimenta [entity]
        if(this.arrows.w) entity.positions[0][1] -= this.settings.chunks.size;
        if(this.arrows.a) entity.positions[0][0] -= this.settings.chunks.size;
        if(this.arrows.s) entity.positions[0][1] += this.settings.chunks.size;
        if(this.arrows.d) entity.positions[0][0] += this.settings.chunks.size;
    },

    out_of_map: function(entity){ //Checa se [entity] saiu do mapa
        if(entity.positions[0][0] < 0) entity.positions[0][0] = canvas.width - this.settings.chunks.size;
        if(entity.positions[0][0] > canvas.width - this.settings.chunks.size) entity.positions[0][0] = 0;
        if(entity.positions[0][1] < 0) entity.positions[0][1] = canvas.height - this.settings.chunks.size;
        if(entity.positions[0][1] > canvas.height - this.settings.chunks.size) entity.positions[0][1] = 0;
    },

    hit_himself: function(entity){ //Checa se [entity] bateu em si
        for(let chunk = 1; chunk < entity.positions.length; chunk++) if(entity.positions[0][0] === entity.positions[chunk][0] && entity.positions[0][1] === entity.positions[chunk][1]) return true;
    },

    check_eat: function(predator, food){    if(predator.positions[0][0] === food.positions[0][0] && predator.positions[0][1] === food.positions[0][1]) return true;    },// Checa se [predator] comeu [food]

    add_point: function(entity){    return entity.positions.push([-50, -50]);    }, //Ganha ponto a [entity]

    remove_point: function(entity){    return entity.positions.pop();    }, // Remove ponto de [entity]

    update_score: function(){    return score.innerText = this.predator.positions.length;    },

    generate_food: function(entity){ // Gera comida de forma que ela tenha os mesmos eixos que [entity]
        let [x, y] = [Number(`${Math.floor(Math.random() * (canvas.width - this.settings.chunks.size) / 10)}0`), Number(`${Math.floor(Math.random() * (canvas.height - this.settings.chunks.size) / 10)}0`)];
        x += (x % this.settings.chunks.size <= 25 ? -(x % this.settings.chunks.size) : (this.settings.chunks.size - (x % this.settings.chunks.size)));
        y += (y % this.settings.chunks.size <= 25 ? -(y % this.settings.chunks.size) : (this.settings.chunks.size - (y % this.settings.chunks.size)));
        return entity.positions.push([x, y]);
    },

    apply_configs: function(){ // Aplica valores armazenados nos inputs para as variáveis atuais do jogo
        canvas.width = Number(iCanvasWidth.value);
        canvas.height = Number(iCanvasHeight.value);

        game.settings.time = Number(iRenderTime.value);
        game.settings.chunks.size = Number(iElementsSize.value);
        game.predator.color = `${iPredatorColor.value}`;
        game.food.color = `${iFoodColor.value}`;
    },

    mode: { // modos de jogo
        default: function(){ // Modo padrão
            iRenderTime.value = 50;
            iElementsSize.value = 20;
            iCanvasWidth.value = 500;
            iCanvasHeight.value = 500;
        }
    }
}

// Lendo entradas e checando se elas são as entradas definidas para o controle do jogador.
window.addEventListener('keypress', e => {    if(Object.keys(game.arrows).indexOf(e.key.toLowerCase()) != -1) for(let key of Object.keys(game.arrows)) game.arrows[key] = (e.key.toLowerCase() === key ? true : false);    });

startButton.addEventListener('click', e => { // Evento de clique do botão start

    //Definindo valores das variáveis de configurações de jogo.
    if(!game.settings.advanced_settings) game.mode.default();
    game.apply_configs();

    //Definindo configurações para que o jogo começe
    let conditions_to_start = [ // Testa se todas as condições abaixo são verdadeiras

        game.settings.time > 0, // Intervalo definido é maior que 0

        game.settings.chunks.size > 0, // Tamanho do bloco do elemento é maior que 0

        canvas.width > 0, // Largura do canvas é maior que 0

        canvas.height > 0, // Altura do canvas é maior que 0
        
        // =-> as condições a seguir são para que todos os blocos de todas as entidades percorram as mesmas coordenadas, e para que o canvas possa abrigar todos esses blocos perfeitamente, sem sobras de espaço.
        canvas.width % 2 === 0 && // Largura do canvas é par
        game.settings.chunks.size % 2 === 0 && // Largura do bloco é par
        canvas.height % 2 === 0 && // Altura do canvas é par
        game.settings.chunks.size % 2 === 0 && //  Altura do bloco é par
        canvas.width % game.settings.chunks.size === 0 && // Largura do Elemento pode ser uniformemente divisivel na arena
        canvas.height % game.settings.chunks.size === 0 // Altura do elemento pode ser uniformemente divisivel na arena
        || // As seguintes instruções são as mesmas, porém para números ímpares
        canvas.width % 2 !== 0 &&
        game.settings.chunks.size % 2 !== 0 &&
        canvas.height % 2 !== 0 &&
        game.settings.chunks.size % 2 !== 0 &&
        canvas.width % game.settings.chunks.size === 0 &&
        canvas.height % game.settings.chunks.size === 0
    
    ];

    //Checando se todas as condições são verdadeiras e executando os comandos
    if(conditions_to_start.every((condition) => { return condition})){

        menu.style.display = 'none';
        canvas.style.display = 'flex';
        score.style.display = 'flex';

        game.start();
    }
});

const hidden_settings = function(){ // Mostrando componentes de configurações avançadas
    game.settings.advanced_settings = true;
    document.querySelectorAll('.hidden').forEach((element) => {
        element.classList.remove('hidden');
    });
}